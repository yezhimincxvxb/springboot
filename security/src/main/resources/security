###
https://spring.io/projects/spring-security
http://www.spring4all.com/article/428
https://blog.csdn.net/yuanlaijike/article/details/80249235

###
<!-- spring security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

### 认证流程
1.  请求过来会被过滤器链中的UsernamePasswordAuthenticationFilter拦截到，
    根据请求中的用户名和密码构造出一个暂时没有鉴权的UsernamePasswordAuthenticationToken(Authentication的实现类)
    并将UsernamePasswordAuthenticationToken提交给认证管理器(AuthenticationManager)进行认证.
2.  AuthenticationManager 本身并不做验证处理，他通过 for-each 遍历找到符合当前登录方式的一个 AuthenticationProvider，
    并交给它进行验证处理，对于用户名密码登录方式，这个 Provider 就是 DaoAuthenticationProvider
3.  DaoAuthenticationProvider通过调用UserDetailsService获取到数据库中存储的用户信息(UserDetails)，
    然后调用passwordEncoder密码编码器对UsernamePasswordAuthenticationToken中的密码和UserDetails中的密码进行比较
4.  DaoAuthenticationProvider认证成功后,会重新构造一个添加了鉴权的 UsernamePasswordAuthenticationToken(用户名，密码，权限等)
    并传回到 UsernamePasswordAuthenticationFilter
5.  Authentication被返回到UsernamePasswordAuthenticationFilter,通过调用SecurityContextHolder工具把Authentication封装成SecurityContext中存储起来。
    然后UsernamePasswordAuthenticationFilter调用AuthenticationSuccessHandler.onAuthenticationSuccess做认证成功后续处理操作
6.  最后SecurityContextPersistenceFilter通过SecurityContextHolder.getContext()获取到SecurityContext对象然后调用
    SecurityContextRepository将SecurityContext存储起来，然后调用SecurityContextHolder.clearContext方法清理SecurityContext。
注意：SecurityContext是一个和当前线程绑定的工具，在代码的任何地方都可以通过SecurityContextHolder.getContext()获取到登陆信息。

### 授权流程
1.当客户端向某个资源发起请求，请求到达FilterSecurityInterceptor，然后会调用其父类AbstractSecurityInterceptor的beforeInvocation方法做授权之前的准备工作
2.在beforeInvocation法中通过SecurityMetadataSource…getAttributes(object);获得资源所需要的访问权限 ，
    通过SecurityContextHolder.getContext().getAuthentication()获取当前认证用户的认证信息，即包含了认证信息和权限信息的Authentication对象
3.然后FilterSecurityInterceptor通过调用AccessDecisionManager.decide(authenticated, object, attributes);
    进行授权(authenticated中有用户的权限列表，attributes是资源需要的权限)，该方法使用投票器投票来决定用户是否有资源访问权限
4.AccessDecisionManager接口有三个实现类，他们通过通过AccessDecisionVoter投票器完成投票，三种投票策略如下：
  AffirmativeBased ： 只需有一个投票赞成即可通过
  ConsensusBased：需要大多数投票赞成即可通过，平票可以配置
  UnanimousBased：需要所有的投票赞成才能通过

  而投票器也有很多，如RoleVoter通过角色投票，如果ConfigAttribute是以“ROLE_”开头的，则将使用RoleVoter进行投票，
  AuthenticatedVoter 是用来区分匿名用户、通过Remember-Me认证的用户和完全认证的用户(登录后的)
  投票通过，请求放行，响应对应的资源给客户端

###  权限
hasRole([role])	当前用户是否拥有指定角色。(必须以)"ROLE_"开头
hasAnyRole([role1,role2])	多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true。
hasAuthority([auth])	等同于hasRole
hasAnyAuthority([auth1,auth2])	等同于hasAnyRole
Principle	代表当前用户的principle对象
authentication	直接从SecurityContext获取的当前Authentication对象
permitAll	总是返回true，表示允许所有的
denyAll	总是返回false，表示拒绝所有的
isAnonymous()	当前用户是否是一个匿名用户
isRememberMe()	表示当前用户是否是通过Remember-Me自动登录的
isAuthenticated()	表示当前用户是否已经登录认证成功了。
isFullyAuthenticated()	如果当前用户既不是一个匿名用户，同时又不是通过Remember-Me自动登录的，则返回true
